\section{Implementation}
\label{sec:impl}
% \begin{itemize}
%   \item implementation - lexical scope transformation
% \end{itemize}

% Two implementations in Scala, as a compiler plugins, starting from the LDL compiler plugins alreasdy available on the net. The rest will describe the important changes
We implemented the ADR transformation as a Scala compiler plugin, by extending the open-source multi-stage programming transformation provided with the Lata Data Layout artifact\footnote{Available at address:\\ \url{https://github.com/miniboxing/staging-plugin}} \cite{ldl}. The development went smoothly, with a few exceptions that we describe here, in hope of aiding future implementers in porting our work to other languages and compilers. We plan to submit our Scala implementation as an artifact and open-source it as soon as the paper is accepted.

The programmer front-end consists of two elements: the |adrt| scope, which acts as a marker for the lexical scope that will be transformed and the |TransformationDescription| class, which programmers need to extend in order to define transformation description objects. These programmer-facing constructs are shown in the Problem Statement section (\S\ref{sec:problem}) and throughout the paper. We will analyze each of these programmer-facing constructs.

% - |adrt| macro => inject phase; very close to the semantics of the multi-stage programming transformation for LDL
The |adrt| scope is responsible for accepting a block of statements and expressions and injecting the annotations that later drives the representation transformation. Initially, we implemented |adrt| as a marker method, that would be executed by the \inject{} phasse. In doing so, realized this is not feasible: the Scala compiler encodes blocks of code passed to methods as anonymous functions. This means that defining a method or class inside the transformed |adrt| scope makes it a part of the anonymous function passed to |adrt| instead of the outer scope of the |adrt| method. This means that, placing the |adrt| scope in a class |C|, any method defined in the scope would not be visible as a method of class |C| during type-checking. Thus valid programs would get rejected because  To fix this, we changed the |adrt| method implementation to use a macro, which, during type-checking, injects the synthetic |@repr| annotations and

% - transformation description objects => bootstrapping problem => annotation

% - transformation description object  => depedency of the code => change it => recompile!

% - bridge - warinings

% - coerce - the main work was around using the extension methods and providing a good solution for them

% - commit -- very simple


