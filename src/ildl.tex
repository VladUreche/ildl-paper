\section{Incremental Late Data Layout}
\label{sec:ildl}

This section will present the Incremental Late Data Layout (ILDL) transformation, by extending the global, all-or-nothing Late Data Layout (LDL) mechanism with the necessary extensions for ad-hoc programmer-driven transformations.

% \subsection{Data Representation Transformations}

% DRT - when the data has more than one representation - generally, the representation can be either more flexible or more efficient
Data can usually be represented in several ways, some which are more efficient while others are more flexible. For example, the integers can use either the primitive (unboxed) value encoding, which is more efficient, or the object-based (boxed) encoding, which provides a more flexible interface offering |toString|, |hashCode| and overloaded operators which can handle all other primitive types, and, more importantly, allow the integer to be stored in erased generics. However, the extra flexibility comes at a heavy price: objects are allocated on the heap and need to be later garbage-collected, reading the value requires an indirect access and cache locality may be broken. There's clearly a tension between the two representations.

% From the language perspective: Expose this difference vs transform in the compiler
From a language perspective, there are two approaches to exposing this tension: either expose the two different data types in the language, as Java and C do, or hide the difference and expose a high-level type, such as Scala does. Although the second aproach is more popular for programmers, as it does not burden them with yet another decision, it requires significant machinery in the compiler, in order to correctly lower the code using the best representation for each case.

% DRTs- two steps: decide on the representation of each value and introduce coercions
% Choosing the representation -- simple, but mind the generics -- for our case, we need to select the values
When lowering the code, the compiler needs to choose the data representation of each value bearing the high-level type and then introduce coercions that transform one representation to another when necessary. For example, since only boxed integers can instantiate generics, any unboxed integer going into a generic container, such as a list of integers, needs to be converted to the boxed representation. This work is done in the compiler pipeline, in so-called data representation transformations.

% Introducing coercions -- optimality question
Furthermore, what makes things even more complicated is the fact that coercions need to be introduced optimally, so the program performance does not suffer. For example, boxing a value can be done in either one step, |box(...)|, or in three steps, sub-optimally: |box(unbox(box(...)))|. Of course, such an obvious sub-optimality is easy to observe, but there are more subtle sub-optimalities which are more difficult to observe and eliminate. This motivated the work on the Late Data Layout mechanism.

\subsection {Late Data Layout}

% In this context, Late data laout was chosen for its ability to selectivity pick values to be transformed and the optimality in introducing coercions
Late Data Layout (LDL) is a compiler transformation that allows selectively picking the representation for each value of a high-level type and automatically introduces the necessary coercions in a consistent and optimal way. The LDL mechanism is the underlying transformation used to unbox primitive types in Scala, to implement value class inlining and to specialize classes using the miniboxed encoding. This makes LDL a flexible and reliable mechanism for translating generics, and thus a natural choice for our starting point in ad-hoc data representation trnasformations.

% What does it do? Starting from a high-level type (or concept), such as |scala.Int|, it transforms all references to low-level representations
The LDL mechanism starts from high-level types (called high-level concepts in the LDL terminology), such as the integer type exposed by Scala, |Int|, which can represent either a boxed or unboxed value in the low-level bytecode. By the time it has finished transforming the code, all values use either the unboxed |int| or boxed |java.lang.Integer| representation, and the necessary coercions between these two representations have been introduced consistently and optimally. For example, the following high-level code:

\begin{lstlisting-nobreak}
val i: Int = 3
val a: Any = i
\end{lstlisting-nobreak}

Is translated to:

\begin{lstlisting-nobreak}
val i: `int` = 3
val a: Any = `box`(i)
\end{lstlisting-nobreak}

How does LDL work? -- injects representation information in the types and uses them to introduce coercions

3 phases: Inject, Coerce, Commit.

% Inject

% Coerce

% Commit

\subsection{Incremental Late Data Layout}

Global vs local/ad-hoc -- relationship between LDL and iLDL + separate compilation

Where does the transformation take place -- difference between high-level signatures and low-level signatures \ldots

Injection -- before storing signatures, bridge, coerce and commit come later.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Persisting the Data Representation information}
\label{sec:ildl:signatures}

% An important question in DRTs: how to modify signatures
%  -- keeping track of transformed methods (do I have a transformed version?)
High-level signatures keep the high-level type, annotated with the transformation description object.

% Persisting the transformation decisions = persisting annotations
%  -- Usage across compilations
%  -- Tracking the transformer
%  -- interoperating between ``islands'' of modified code
%      -- using the same encoding
%      -- using different encodings
We need this in order to save the decisions made during injection.

\subsubsection{Tracking the Transformed Values}
This allows inserting coercions.

\subsubsection{Two Types, One Representation}

What if we have two types that erase to the same representation? Could a method where the first type, say (Int, Int) was converted to long be called by code that was encoding |(Float, Float)| as a long integer, thus compromising the semantics of the language?

The answer is no, since the type system protects us from doing this. The annotations, before the coerce phase, only bear the final representation, but the type exposed is the high-level type, not the representation. Therefore, the error message would make it very clear that the code attempted to call a method accepting a pair of integers but passed a pair of floating-point numbers.

\subsubsection{One Type, One Representation, Compatibility}

Another question we may ask ourselves is what we have the |ildl| marker method called from two different locations with the same transformation description object? Would they need to convert to the high-level (and inefficient type)? The answer is no, since the method signature will have the high-level type annotated with the representation, which will match the arguments for the call.

\subsubsection{One Type, Two Representations}

Finally, a third question one may ask is what if we had a single type, such as |GaussianInteger|, which could be represented as either |(Int, Int)| or |Long|, and attempted to call between parts of the code using the two representations. The answer is that, keeping the high-level signature would allow the ildl transformation to know that it needs to convert from one representation to another: it would first decode the first representation to expose the high-level type, which it would then re-encode with the second representation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Handling Generics and The Object Model}
\label{sec:ildl:generics}

% 2 Aspects \ldots
\subsubsection{Generics}

% Generics
%  -- Nesting datastructures
Can we transform |List[(Int, Int)]| into |List[Long]|. In the general case, no, for two reasons:
\begin{itemize}
  \item since it could break aliasing (for mutable data structures)
  \item since there is no method available to transform from one representation to the other
\end{itemize}

Solution: we could either add methods for transforming data structures in the transformation description object or, if there is no such method available, the correctness-preserving approach is not to transform the representation inside generics.


\subsubsection{The Object Model: Subtyping and Overriding}
% Overriding - introduce an additional phase in LDL: bridge
We add bridges, therefore the ILDL transformation has four phases instead of three: inject, bridge, coerce and commit.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preserving the Semantics}
\label{sec:ildl:semantics}

% Semantics changes
\subsubsection{Methods and Operators of the Object}
% Operators
%  -- transformation tracker
We can always decode the representation to expose the high-level type and make the call based on that. Yet, this is inefficient. The solution is to short-circuit the calls to the operators and perform them directly on the encoded value, much like extension methods work for value classes.

Short-cutting methods are located in the transformation description object, which needs to contain:
\begin{itemize}
  \item transformations between the high-level type and the representation (and back);
  \item (optional) transformations between generic containers with the high-level type (|List[(Int, Int)]|) and the generic container with the improved representation (|List[Long]|);
  \item (optional) operators and methods on the encoded representation, such as |+|, |-|, |*|, |/|, |%| and |norm|.
\end{itemize}

Operators need not required their arguments to use the high-level type: for example, when defining the |+| operator, we need to force the second operator to use the high-level type |(Int, Int)|. Instead, we accept a value of type |@encoded Long|, which allows it to accept the optimized representation for the other value as well. Interestingly, this does not prevent it from accepting the high-level type |(Int, Int)|: based on annotations, the ildl transformation knows the |(Int, Int)| value must be converted to a |Long| value.

\subsubsection{Semantics of the Transformed Type}
%  -- Liskov substitution principle
reviewers may argue that data containers are generic and flexible in order to ease evolution of the data structures. Therefore transforming non-final containers might lose their semantics, since we fix the semantics of operators, which otherwise would have been dynamically dispatched to the most specific implementation. But that can be argued against using the Liskov principle -- if a subclass of the container modifies the behavior of an operator, even the original program's semantics may now be incorrect, therefore our transformation won't make correctness worse. Therefore, according to the Liskov principle, as long as the updated (static) operators are semantically equivalent to the data container's, the transformation will not affect the program semantics.

