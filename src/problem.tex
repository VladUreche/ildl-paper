\section{Motivation}
\label{sec:problem}

% Executive summary + vision
This section presents the full motivating example featuring the complex number tranformation, which we use throughout the paper. It then shows how the data representation transformation is triggered and introduces the terminology. Finally, it shows a naive transformation, hinting at the difficulties lying ahead.

\subsection{Motivating Example}

In the introduction, we focused on adding complex number semantics to
pairs of integers. Complex numbers with integers as both their real
and imaginary parts are known as Gaussian integers, and are a
countable subset of all complex numbers. The operations defined on
Gaussian integers are similar to complex number operations, with one
exception: to satisfy the abelian closure property, division is not precise,
but instead rounds the result to the nearest Gaussian integer, with both the real and imaginary
axes containing integers. This is similar to integer division, which
also rounds the result, so that, for example, |5/2| produces value
|2|.

% The following implicit class defines the Gaussian integer operators on pairs of integer numbers:
% \vlad{should we include this or spare the reader?}
% \begin{lstlisting-nobreak}
% implicit class PairOfIntAsGaussianInteger(n1: (Int, Int)) {
%   def c = (n1.re, -n1.im) // conjugate 1+2i => 1-2i
%   def re = n1._1
%   def im = n1._2
%   def norm = n1.re * n1.re + n1.im * n1.im
%   def +(n2: (Int, Int)): (Int, Int) = (n1.re + n2.re, n1.im + n2.im)
%   def -(n2: (Int, Int)): (Int, Int) = (n1.re - n2.re, n1.im - n2.im)
%   def *(n2: (Int, Int)): (Int, Int) = (n1.re * n2.re - n1.im * n2.im, n1.re * n2.im + n1.im * n2.re)
%   def /(n2: (Int, Int)): (Int, Int) = {
%     val denom = n2 * n2.c
%     val numer = n1 * n2.c
%     assert(denom.im == 0) // by multiplying with the conjugate, we reduce the imaginary part of the denominator
%     (math.round(numer.re.toFloat / denom.re), math.round(numer.im.toFloat / denom.re))
%   }
% }
% \end{lstlisting-nobreak}

An interesting property of Gaussian integers is that we can define the
``divides'' relation and the greatest common divisor (GCD) between any
two Gaussian integers. Furthermore, computing the GCD is similar to
Euclid's algorithm for integer numbers:

\begin{lstlisting-nobreak}
def gcd(n1: (Int, Int), n2: (Int, Int)): (Int, Int) = {
  val remainder = n1 % n2
  if (remainder.norm == 0) n2 else gcd(n2, remainder)
}
\end{lstlisting-nobreak}

Unfortunately, as our algorithm recursively computes the result, it creates linearly many pairs of integers, allocating them on the heap. If we run this algorithm with no optimizations, computing the GCD takes around 3 microseconds (on the same setup as used for our full experiments in \S\ref{sec:benchmarks}):

\begin{lstlisting-nobreak}
scala> timed(() => gcd((544, 185), (131, 181)))
The operation took `3.05 us` (based on 10000 executions).
The result was (10, 3).
\end{lstlisting-nobreak}

However, if we encode the Gaussian integers into 64-bit long integers, we improve the time by a factor of 13x:

\begin{lstlisting-nobreak}
scala> timed(() => gcd((544, 185), (131, 181)))
The operation took `0.23 us` (based on 10000 executions).
The result was (10, 3).
\end{lstlisting-nobreak}

This makes a data representation transformation highly desirable. Still, making the programmer transform the code by hand is tedious and error-prone, so a natural question to ask is whether the transformation could be automated.

\subsection{Automating the Transformation}
\label{sec:automating}

In order to reap the benefits of using the improved representation
without manually transforming the code, we present the Ad hoc Data
Representation (ADR) Transformation technique, which can be triggered
by the |adrt| marker method. This method accepts two parameters: the
first parameter is a \emph{transformation description object} and the
second is a block of code that forms the transformation scope. This
scope can contain anything from expressions all the way to method, class,
trait and object definitions:

\begin{lstlisting-nobreak}
`adrt(IntPairComplexToLongComplex)` {
 def gcd(n1: (Int, Int), n2: (Int, Int)):(Int, Int)={
   val remainder = n1 % n2
   if (remainder.norm == 0) n2 else gcd(n2, remainder)
 }
}
\end{lstlisting-nobreak}

To maintain a consistent naming throughout the paper, we will
use the name \emph{high-level type} to designate |(Int, Int)|, which
corresponds to the original type in the code. This high-level type can
be encoded as its \emph{representation type}, |Long|. The high-level
type, its representation, and the procedures for encoding and decoding
are all stored in the transformation description object, in our case
|IntPairComplexToLongComplex|. With this, we have the vocabulary
necessary to reason about our first (naive) approach to transforming
the code.

\subsection{A Naive Transformation}

% It's important that's not a trivial transformation -- users will transform their input ... we'll look at this aspect again when rev
Despite its simple interface, the Ad hoc Data Representation Transformation mechanism is by no means simple. For example, knowing that the |adrt| marker was instructed to transform |(Int, Int)| to |Long|, a naive result could be:

\begin{lstlisting-nobreak}
def gcd(n1: `Long`, n2: `Long`): `Long` = {
  val remainder = n1 % n2
  if (remainder.norm == 0) n2 else gcd(n2, remainder)
}
\end{lstlisting-nobreak}

There are many questions one could ask about this naive translation. For example, how does the compiler know which parameters and values to transform to the long integer representation (\S\ref{sec:ildl:custom})? How and when to encode and decode values, and what to do about values that are visible outside the scope (\S\ref{sec:ildl:scoped})? Even worse, what if parts of the code are compiled separately, in a different compiler run (\S\ref{sec:ildl:separate-compilation})?

Going into the semantics of the program, we can ask if the |%| (modulo) operator maintains the semantics of complex numbers when used for long integers. Also, is |norm| defined for long integers? Unfortunately, the response to both questions is negative. Therefore, the transformation needs to preserve semantics, which is not trivial (\S\ref{sec:ildl:method}).

We could also ask what would happen if |gcd| was overriding another method, as in the code fragment below. Would the new signature still override it? The answer is no, so the naive translation would break the object model (\S\ref{sec:ildl:language-features}).

\begin{lstlisting-nobreak}
trait WithGCD[`T`] {
  def gcd(n1: `T`, n2: `T`): `T`
}
class Complex extends WithGCD[`(Int, Int)`] {
  // expected: gcd(n1: (Int, Int), n2: (Int, Int)) ...
  // found:    gcd(n1: Long, n2: Long): Long
  // (which does not implement gcd in trait WithGCD)
  def gcd(n1: `Long`, n2: `Long`): `Long` = ...
}
\end{lstlisting-nobreak}

Our approach, the Ad hoc Data Representation Transformation, addresses these questions.
% and preserves semantics. %But before presenting our approach, we need some background on data representation transformations.

