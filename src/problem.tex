\section{Motivation}
\label{sec:problem}

% Executive summary + vision
This section presents a motivating example based on complex numbers, which we use throughout the paper. It then shows how the data representation transformation is triggered and introduces its terminology. Finally, it shows a naive transformation, allowing us to see the difficulties lying ahead.

\subsection{Motivating Example}

In the introduction, we focused on adding complex number semantics to pairs of integers. The complex numbers where the real and imaginary parts are integers are known as Gaussian integers, and are a countable subset of all complex numbers. The operations defined on Gaussian integers are similar to complex number operations, with one exception: division is not precise, as it rounds the result to the nearest Gaussian integer, meaning both the real and imaginary axes will contain integers. This is similar to integer division, which also rounds the result, such that, for example, |5/2| produces value |2|.

% The following implicit class defines the Gaussian integer operators on pairs of integer numbers:
% \vlad{should we include this or spare the reader?}
% \begin{lstlisting-nobreak}
% implicit class PairOfIntAsGaussianInteger(n1: (Int, Int)) {
%   def c = (n1.re, -n1.im) // conjugate 1+2i => 1-2i
%   def re = n1._1
%   def im = n1._2
%   def norm = n1.re * n1.re + n1.im * n1.im
%   def +(n2: (Int, Int)): (Int, Int) = (n1.re + n2.re, n1.im + n2.im)
%   def -(n2: (Int, Int)): (Int, Int) = (n1.re - n2.re, n1.im - n2.im)
%   def *(n2: (Int, Int)): (Int, Int) = (n1.re * n2.re - n1.im * n2.im, n1.re * n2.im + n1.im * n2.re)
%   def /(n2: (Int, Int)): (Int, Int) = {
%     val denom = n2 * n2.c
%     val numer = n1 * n2.c
%     assert(denom.im == 0) // by multiplying with the conjugate, we reduce the imaginary part of the denominator
%     (math.round(numer.re.toFloat / denom.re), math.round(numer.im.toFloat / denom.re))
%   }
% }
% \end{lstlisting-nobreak}

What is interesting about Gaussian integers is that we can define the ``divides'' relation and the greatest common divisor (GCD) between any two Gaussian integers. Furthermore, computing the GCD is similar to the Euclidean algorithm for integer numbers:

\begin{lstlisting-nobreak}
def gcd(n1: (Int, Int), n2: (Int, Int)): (Int, Int) = {
  val remainder = n1 % n2
  if (remainder.norm == 0) n2 else gcd(n2, remainder)
}
\end{lstlisting-nobreak}

Unfortunately, as the algorithm recursively computes the result, it creates linearly many pairs of integers, allocating them in the heap memory. If we were to run this algorithm without any compiler and virtual machine optimizations, each GCD operation would take around 130 microseconds:

\begin{lstlisting-nobreak}
scala>   println(timed(() => gcd((544, 185), (131, 181))))
The operation took `127 us`.
(10,3)
\end{lstlisting-nobreak}

However, if we encoded the Gaussian integers into 64-bit long integers, we would improve the time by a factor of 4x:

\begin{lstlisting-nobreak}
scala> println(timed(() => gcd((544, 185), (131, 181))))
The operation took `32 us`.
(10,3)
\end{lstlisting-nobreak}

This makes the data representation transformation highly desirable. Still, letting the programmer transform the code by hand is both tedious, error-prone and sacrifices code maintainability. This begs the question: can this transformation be automated?

\subsection{Automating the Transformation}

In order to reap the benefits of using the improved representation without manually transforming the code, we present the Ad hoc Data Representation Transformation technique, which can be triggered by the |adrt| marker method. This method accepts two parameters: the first parameter describes the desired transformation and the second is a block of code, which, aside from expressions, can also define classes, traits, objects and methods:

\begin{lstlisting-nobreak}
`adrt(IntPairComplexToLongComplex)` {
  def gcd(n1: (Int, Int), n2: (Int, Int)): (Int, Int) = {
    val remainder = n1 % n2
    if (remainder.norm == 0) n2 else gcd(n2, remainder)
  }
}
\end{lstlisting-nobreak}

In order to maintain a consistent naming throughout the paper, we will use the name high-level type to designate |(Int, Int)|, which corresponds to the original type in the code. This high-level type can be encoded as its representation type, |Long|. The the high-level type, its representation and the procedures for encoding and decoding are all stored in the transformation description object, in our case |IntPairComplexToLongComplex|. With this, we have the vocabulary necessary to reason about our first (naive) approach to transforming the code.

\subsection{A Naive Transformation}

% It's important that's not a trivial transformation -- users will transform their input ... we'll look at this aspect again when rev
Despite its interface, the Ad hoc Data Representation Transformation mechanism is by no means simple. For example, knowing the |adrt| marker was instructed to transform |(Int, Int)| to |Long|, a naive result could be:

\begin{lstlisting-nobreak}
def gcd(n1: `Long`, n2: `Long`): `Long` = {
  val remainder = n1 % n2
  if (remainder.norm == 0) n2 else gcd(n2, remainder)
}
\end{lstlisting-nobreak}

There are many questions one could ask about this naive translation. For example, does the |%| (modulo) operator maintain the semantics of complex numbers when using the implementation from long integers? Or, is |norm| defined for long integers? Unfortunately, the response is negative for both questions. Therefore, the transformation needs to preserve semantics, which is not trivial (\S\ref{sec:ildl:semantics}).

Moreover, we could ask what happens if |gcd| was overriding another method? Would the new signature still override it? The answer is no (\S\ref{sec:ildl:generics}):

\begin{lstlisting-nobreak}
trait WithGCD[`T`] {
  def gcd(n1: `T`, n2: `T`): `T`
}

class Complex extends WithGCD[`(Int, Int)`] {
  def gcd(n1: `Long`, n2: `Long`): `Long` = ...
  // expected: gcd(n1: (Int, Int), n2: (Int, Int)): (Int, Int)
  // found:    gcd(n1: Long, n2: Long): Long
  // (which does not override method gcd in trait WithGCD)
}
\end{lstlisting-nobreak}
% \end{lstlisting-nobreak}
%
% \begin{lstlisting-nobreak}

Last but not least, assuming write a piece of code calling |gcd|:

\begin{lstlisting-nobreak}
gcd((55,2), (17, 13))
\end{lstlisting-nobreak}

Then, how does the compiler know what encoding/decoding procedures to use to convert the pairs of integers to the long integer representation? Even worse, what if the code is compiled in a separate compilation (\S\ref{sec:ildl:signatures})?

We will answer all these questions in the next section, which presents the Ad hoc Data Representation Transformation mechanism.
