\section{Motivation}
\label{sec:problem}

% Executive summary + vision
This section presents a motivating example, which we use throughout the paper. It further shows the API necessary to trigger the transformation and a naive approach to changing the data representation. The naive approach allows us to see the main difficulties in ad-hoc data representation transformations, thus motivating the next section.

\subsection{Motivating Example}

In the introduction, we focused on adding complex number semantics to pairs of numbers. The complex numbers where the real and imaginary parts are integers are known as Gaussian integers, and are a countable subset of all complex numbers (with real number components). The operations defined on Gaussian integers are similar to complex number operations, with one exception: division is not precise, as it rounds the result to the nearest Gaussian integer, meaning both the real and imaginary axes will contain integers. This is similar to integer division, which also rounds the result.

% The following implicit class defines the Gaussian integer operators on pairs of integer numbers:
% \vlad{should we include this or spare the reader?}
% \begin{lstlisting-nobreak}
% implicit class PairOfIntAsGaussianInteger(n1: (Int, Int)) {
%   def c = (n1.re, -n1.im) // conjugate 1+2i => 1-2i
%   def re = n1._1
%   def im = n1._2
%   def norm = n1.re * n1.re + n1.im * n1.im
%   def +(n2: (Int, Int)): (Int, Int) = (n1.re + n2.re, n1.im + n2.im)
%   def -(n2: (Int, Int)): (Int, Int) = (n1.re - n2.re, n1.im - n2.im)
%   def *(n2: (Int, Int)): (Int, Int) = (n1.re * n2.re - n1.im * n2.im, n1.re * n2.im + n1.im * n2.re)
%   def /(n2: (Int, Int)): (Int, Int) = {
%     val denom = n2 * n2.c
%     val numer = n1 * n2.c
%     assert(denom.im == 0) // by multiplying with the conjugate, we reduce the imaginary part of the denominator
%     (math.round(numer.re.toFloat / denom.re), math.round(numer.im.toFloat / denom.re))
%   }
% }
% \end{lstlisting-nobreak}

What is interesting about Gaussian integers is that we can define the division relation and the greatest common divisor (GCD) between any two numbers. Furthermore, computing the GCD is similar to the Euclidean algorithm for integers:

\begin{lstlisting-nobreak}
def gcd(n1: (Int, Int), n2: (Int, Int)): (Int, Int) = {
  val rem = n1 % n2
  if (rem.norm == 0) n2 else gcd(n2, remainder)
}
\end{lstlisting-nobreak}

Unfortunately, as the algorithm recursively computes the result, it creates linearly many pairs of integers, allocating them in the heap memory. If we were to run this algorithm without any virtual machine optimizations, each GCD operation would take around 100 microseconds:

\begin{lstlisting-nobreak}
scala>   println(timed(() => gcd((544, 185), (131, 181))))
The operation took `98 us`.
(10,3)
\end{lstlisting-nobreak}

However, if we encoded the Gaussian integers into 64-bit long integers instead of heap pairs of objects, we would improve the time by a factor of 3:

\begin{lstlisting-nobreak}
scala> println(timed(() => gcd((544, 185), (131, 181))))
The operation took `32 us`.
(10,3)
\end{lstlisting-nobreak}

Therefore, this is a highly desirable transformation. However, requiring the programmer to transform the code by hand is both tedious and error-prone.

\subsection{Triggering the Transformation}

In order to reap the benefits of using the improved representation without manually transforming the code, we can rely on the compiler for an automated solution. To do so, we call the |ildl| marker method, which accepts a parameter describing the desired transformation and a block of code, which, aside from expressions, can also define classes, traits, objects and methods:

\begin{lstlisting-nobreak}
`ildl(IntPairComplexToLongComplex)` {
  def gcd(n1: (Int, Int), n2: (Int, Int)): (Int, Int) = {
    val rem = n1 % n2
    if (rem.norm == 0) n2 else gcd(n2, remainder)
  }
}
\end{lstlisting-nobreak}

In order to maintain a consistent naming throughout the paper, we will use the name high-level type to designate |(Int, Int)|, which corresponds to the original type in the code. This high-level type can be encoded as its representation type, |Long|. The procedure to encode and decode the high-level type is stored in the transformation description object, in our case |IntPairComplexToLongComplex|. With this, we have all the necessary information to perform the Incremental Late Data Layout transformation.

\subsection{A Naive Approach}

% It's important that's not a trivial transformation -- users will transform their input ... we'll look at this aspect again when rev
Despite its interface, the Incremental Late Data Layout is by no means a simple transformation. For example, knowing the |ildl| marker was instructed to transform |(Int, Int)| to |Long|, the result of a naive code transformation could be:

\begin{lstlisting-nobreak}
def gcd(n1: `Long`, n2: `Long`): `Long` = {
  val rem = n1 % n2
  if (rem.norm == 0) n2 else gcd(n2, remainder)
}
\end{lstlisting-nobreak}

There are many questions one could ask about this naive translation. For example, is the |%| (modulo) operator the same on long integers and encoded complex numbers? Or, is there a |norm| defined for long integers? Unfortunately, the response is negative for both questions.

Therefore, the transformation needs to preserve semantics, which is not trivial (\S\ref{sec:ildl:semantics}). Moreover, we could ask what happens if the |gcd| method was overriding another method? Would the new signature still override it?


\begin{lstlisting-nobreak}
trait WithGCD[`T`] {
  def gcd(n1: `T`, n2: `T`): `T`
}

class Complex extends WithGCD[`(Int, Int)`] {
  def gcd(n1: `Long`, n2: `Long`): `Long` = ...
  // expected: gcd(n1: (Int, Int), n2: (Int, Int)): (Int, Int)
  // found:    gcd(n1: Long, n2: Long): Long
  // (which does not override method gcd in trait WithGCD)
}
\end{lstlisting-nobreak}
% \end{lstlisting-nobreak}
%
% \begin{lstlisting-nobreak}

This would not be the case, preventing the |Complex| class from compiling. Last but not least, assuming write a piece of code calling |gcd|:

\begin{lstlisting-nobreak}
gcd((55,2), (17, 13))
\end{lstlisting-nobreak}

Then, how does the compiler bridge the gap between the pairs of integers and their long integer encoding when compiling this code? Even worse, what if the code is compiled in a separate compilation?


first, the additional Gaussian integer operators, such as the modulo operator, have to be translated to use the 64-bit encoding. Also, as the signature of the |gcd| method changes, it forces its call sites to use the updated data representation, so the effects ripple out. Finally, there is a question of transforming geneics, including collections and arrays -- should the representation be optimized there as well? These are a few of the issues we encountered in our incremental data representation transformations, and which we further present in this paper.
