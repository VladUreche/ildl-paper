\section{Motivation}
\label{sec:problem}

% Executive summary + vision
This section presents a motivating example based on complex numbers, which we use throughout the paper. It then shows how the data representation transformation is triggered and introduces its terminology. Finally, it shows a naive transformation, allowing us to see the difficulties lying ahead.

\subsection{Motivating Example}

In the introduction, we focused on adding complex number semantics to
pairs of integers. Complex numbers with integers as both their real
and imaginary parts are known as Gaussian integers, and are a
countable subset of all complex numbers. The operations defined on
Gaussian integers are similar to complex number operations, with one
exception: division is not precise, as it rounds the result to the
nearest Gaussian integer, meaning that both the real and imaginary
axes will contain integers. This is similar to integer division, which
also rounds the result, so that, for example, |5/2| produces value
|2|.

% The following implicit class defines the Gaussian integer operators on pairs of integer numbers:
% \vlad{should we include this or spare the reader?}
% \begin{lstlisting-nobreak}
% implicit class PairOfIntAsGaussianInteger(n1: (Int, Int)) {
%   def c = (n1.re, -n1.im) // conjugate 1+2i => 1-2i
%   def re = n1._1
%   def im = n1._2
%   def norm = n1.re * n1.re + n1.im * n1.im
%   def +(n2: (Int, Int)): (Int, Int) = (n1.re + n2.re, n1.im + n2.im)
%   def -(n2: (Int, Int)): (Int, Int) = (n1.re - n2.re, n1.im - n2.im)
%   def *(n2: (Int, Int)): (Int, Int) = (n1.re * n2.re - n1.im * n2.im, n1.re * n2.im + n1.im * n2.re)
%   def /(n2: (Int, Int)): (Int, Int) = {
%     val denom = n2 * n2.c
%     val numer = n1 * n2.c
%     assert(denom.im == 0) // by multiplying with the conjugate, we reduce the imaginary part of the denominator
%     (math.round(numer.re.toFloat / denom.re), math.round(numer.im.toFloat / denom.re))
%   }
% }
% \end{lstlisting-nobreak}

An interesting property of Gaussian integers is that we can define the
``divides'' relation and the greatest common divisor (GCD) between any
two Gaussian integers. Furthermore, computing the GCD is similar to
Euclid's algorithm for integer numbers:

\begin{lstlisting-nobreak}
def gcd(n1: (Int, Int), n2: (Int, Int)): (Int, Int) = {
  val remainder = n1 % n2
  if (remainder.norm == 0) n2 else gcd(n2, remainder)
}
\end{lstlisting-nobreak}

%% \yannis{The ``no virtual machine optimizations'' claim sounds weak. Maybe ``a stock VM''?}
Unfortunately, as the algorithm recursively computes the result, it creates linearly many pairs of integers, allocating them in the heap memory. If we run this algorithm without any compiler
%% and virtual machine
optimizations, each GCD operation takes around 130
microseconds (on the same setup as used for our full experiments):
%%\yannis{on what machine setup?}:

\begin{lstlisting-nobreak}
scala>   println(timed(() => gcd((544, 185), (131, 181))))
The operation took `127 us`.
(10,3)
\end{lstlisting-nobreak}

However, if we encode the Gaussian integers into 64-bit long integers, we improve the time by a factor of 4x:

\begin{lstlisting-nobreak}
scala> println(timed(() => gcd((544, 185), (131, 181))))
The operation took `32 us`.
(10,3)
\end{lstlisting-nobreak}

This makes the data representation transformation highly desirable. Still, letting the programmer transform the code by hand is tedious and error-prone, and sacrifices code maintainability. This begs the question: can this transformation be automated?

\subsection{Automating the Transformation}
\label{sec:automating}

In order to reap the benefits of using the improved representation
without manually transforming the code, we present the Ad hoc Data
Representation (ADR) Transformation technique, which can be triggered
by the |adrt| marker method. This method accepts two parameters: the
first parameter is a \emph{transformation description object} and the
second is a block of code that forms the transformation scope. This
scope can contain expressions, but also classes, traits, objects and
methods:

\begin{lstlisting-nobreak}
`adrt(IntPairComplexToLongComplex)` {
  def gcd(n1: (Int, Int), n2: (Int, Int)): (Int, Int) = {
    val remainder = n1 % n2
    if (remainder.norm == 0) n2 else gcd(n2, remainder)
  }
}
\end{lstlisting-nobreak}

To maintain a consistent naming throughout the paper, we will
use the name \emph{high-level type} to designate |(Int, Int)|, which
corresponds to the original type in the code. This high-level type can
be encoded as its \emph{representation type}, |Long|. The high-level
type, its representation, and the procedures for encoding and decoding
are all stored in the transformation description object, in our case
|IntPairComplexToLongComplex|. With this, we have the vocabulary
necessary to reason about our first (naive) approach to transforming
the code.

\subsection{A Naive Transformation}

% It's important that's not a trivial transformation -- users will transform their input ... we'll look at this aspect again when rev
Despite its interface, the Ad hoc Data Representation Transformation mechanism is by no means simple. For example, knowing that the |adrt| marker was instructed to transform |(Int, Int)| to |Long|, a naive result could be:

\begin{lstlisting-nobreak}
def gcd(n1: `Long`, n2: `Long`): `Long` = {
  val remainder = n1 % n2
  if (remainder.norm == 0) n2 else gcd(n2, remainder)
}
\end{lstlisting-nobreak}

There are many questions one could ask about this naive translation. For example, does the |%| (modulo) operator maintain the semantics of complex numbers when using the implementation for long integers? Or, is |norm| defined for long integers? Unfortunately, the response is negative on both questions. Therefore, the transformation needs to preserve semantics, which is not trivial (\S\ref{sec:ildl:semantics}).

Moreover, we could ask what happens if |gcd| was overriding another method? Would the new signature still override it? The answer is no (\S\ref{sec:ildl:generics}):

\begin{lstlisting-nobreak}
trait WithGCD[`T`] {
  def gcd(n1: `T`, n2: `T`): `T`
}

class Complex extends WithGCD[`(Int, Int)`] {
  def gcd(n1: `Long`, n2: `Long`): `Long` = ...
  // expected: gcd(n1: (Int, Int), n2: (Int, Int)): (Int, Int)
  // found:    gcd(n1: Long, n2: Long): Long
  // (which does not override method gcd in trait WithGCD)
}
\end{lstlisting-nobreak}
% \end{lstlisting-nobreak}
%
% \begin{lstlisting-nobreak}

Last but not least, consider a piece of code that calls |gcd|:

\begin{lstlisting-nobreak}
gcd((55,2), (17, 13))
\end{lstlisting-nobreak}

How does the compiler know what encoding/decoding procedures to use to convert the pairs of integers to the long integer representation? Even worse, what if the code is compiled separately, in a different compilation unit (\S\ref{sec:ildl:signatures})?

%%\yannis{``Next section'' is not accurate. This doesn't come until later.}
%We answer these questions in the next section, which presents the Ad hoc Data 
%Representation Transformation mechanism.
